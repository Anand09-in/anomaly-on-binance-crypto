#!/usr/bin/env bash
# Kafka/Producer/producer_start.sh
set -euo pipefail

echo "[producer_start] Starting Binance producer deployment..."

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

ENV_JSON="${ENV_JSON:-$SCRIPT_DIR/config.json}"
ENV_FILE="${ENV_FILE:-$SCRIPT_DIR/.env}"
COMPOSE_FILE="${COMPOSE_FILE:-$SCRIPT_DIR/docker-compose.yaml}"
TMP_ENV="${ENV_FILE}.tmp"

# 1) Check compose file
if [ ! -f "$COMPOSE_FILE" ]; then
  echo "[producer_start] ERROR: docker-compose file not found at $COMPOSE_FILE"
  exit 1
fi

# 2) Ensure jq is installed
if ! command -v jq >/dev/null 2>&1; then
  echo "[producer_start] jq not found, installing..."
  sudo apt-get update -y
  sudo apt-get install -y jq
fi

# 3) Generate .env from config.json (atomic write)
if [ ! -f "$ENV_JSON" ]; then
  echo "[producer_start] ERROR: config JSON $ENV_JSON not found"
  exit 1
fi

echo "[producer_start] Generating .env from $ENV_JSON → $ENV_FILE (temp $TMP_ENV)"
{
  echo "# Auto-generated by producer_start.sh on $(date -Iseconds)"

  # Convert JSON key/value pairs to KEY=VALUE lines (tostring ensures non-objects)
  jq -r 'to_entries | .[] | "\(.key)=\(.value|tostring)"' "$ENV_JSON"

  # Add HOST_PRIVATE_IP from EC2 metadata (if available)
  HOST_PRIVATE_IP="$(curl -s --max-time 2 http://169.254.169.254/latest/meta-data/local-ipv4 || echo "")"
  if [ -n "$HOST_PRIVATE_IP" ]; then
    echo "HOST_PRIVATE_IP=$HOST_PRIVATE_IP"
    # Provide bootstrap servers using host ip (kept for convenience)
    echo "KAFKA_BOOTSTRAP_SERVERS=${HOST_PRIVATE_IP}:9092,${HOST_PRIVATE_IP}:9093,${HOST_PRIVATE_IP}:9094"
  fi
} > "$TMP_ENV"

# move into place atomically
mv "$TMP_ENV" "$ENV_FILE"
chmod 600 "$ENV_FILE"
echo "[producer_start] Generated .env (first 50 lines):"
head -n 50 "$ENV_FILE" || true

# 4) Decide docker compose command
if command -v docker >/dev/null 2>&1 && docker compose version >/dev/null 2>&1; then
  DC_CMD="docker compose"
elif command -v docker-compose >/dev/null 2>&1; then
  DC_CMD="docker-compose"
else
  echo "[producer_start] ERROR: neither 'docker compose' nor 'docker-compose' found"
  exit 1
fi

# 5) ECR Login — prefer instance role (no creds), fallback to aws cli if env set
if [ -n "${ECR_REGISTRY:-}" ] && [ -n "${AWS_REGION:-}" ]; then
  echo "[producer_start] Attempting ECR login to $ECR_REGISTRY"
  if aws sts get-caller-identity >/dev/null 2>&1; then
    echo "[producer_start] Using instance role or configured AWS creds for ECR login"
    aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$ECR_REGISTRY"
  else
    echo "[producer_start] AWS CLI cannot call STS — skipping ECR login (no creds)"
  fi
else
  echo "[producer_start] ECR_REGISTRY/AWS_REGION not set — skipping ECR login"
fi

# 6) Pull latest image with retries (network/ECR can be flaky)
retry() {
  local n=0
  local max=5
  local delay=5
  until "$@"; do
    n=$((n+1))
    if [ $n -ge $max ]; then
      echo "[producer_start] Command failed after $n attempts: $*"
      return 1
    fi
    echo "[producer_start] Command failed — retry $n/$max in ${delay}s..."
    sleep $delay
  done
  return 0
}

echo "[producer_start] Pulling latest images using $DC_CMD..."
retry $DC_CMD --env-file "$ENV_FILE" -f "$COMPOSE_FILE" pull

echo "[producer_start] Starting/updating containers..."
$DC_CMD --env-file "$ENV_FILE" -f "$COMPOSE_FILE" up -d

# 7) Wait for container health (if healthcheck is configured)
SERVICE_NAME="binance-producer"
echo "[producer_start] Waiting for $SERVICE_NAME to become healthy (timeout 300s)..."
SECONDS_WAITED=0
TIMEOUT=300
SLEEP_INTERVAL=5

while [ "$SECONDS_WAITED" -lt "$TIMEOUT" ]; do
  # get container id(s) for the service
  CONTAINER_IDS=$(docker ps --filter "name=${SERVICE_NAME}" --format '{{.ID}}' || true)
  if [ -z "$CONTAINER_IDS" ]; then
    echo "[producer_start] Container for $SERVICE_NAME not found yet. Sleeping..."
    sleep $SLEEP_INTERVAL
    SECONDS_WAITED=$((SECONDS_WAITED + SLEEP_INTERVAL))
    continue
  fi

  ALL_HEALTHY=true
  for cid in $CONTAINER_IDS; do
    # if container doesn't have healthcheck, consider it 'running' as success
    HC=$(docker inspect --format='{{json .State.Health}}' "$cid" 2>/dev/null || true)
    if [ -z "$HC" ] || [ "$HC" = "null" ]; then
      # No health check — check status is 'running'
      STATUS=$(docker inspect --format='{{.State.Status}}' "$cid")
      if [ "$STATUS" != "running" ]; then
        ALL_HEALTHY=false
      fi
    else
      HSTAT=$(docker inspect --format='{{.State.Health.Status}}' "$cid" || echo "unknown")
      if [ "$HSTAT" != "healthy" ]; then
        ALL_HEALTHY=false
      fi
    fi
  done

  if $ALL_HEALTHY ; then
    echo "[producer_start] Service $SERVICE_NAME is healthy"
    break
  fi

  sleep $SLEEP_INTERVAL
  SECONDS_WAITED=$((SECONDS_WAITED + SLEEP_INTERVAL))
done

if [ "$SECONDS_WAITED" -ge "$TIMEOUT" ]; then
  echo "[producer_start] ERROR: Timeout waiting for $SERVICE_NAME to become healthy"
  docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}"
  exit 1
fi

echo "[producer_start] Current containers:"
docker ps --format "table {{.Names}}\t{{.Image}}\t{{.Status}}"

echo "[producer_start] ✅ Producer deployment complete."
